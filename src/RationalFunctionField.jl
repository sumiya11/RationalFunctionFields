
#=
    TODO: how to address good ideal?

=#


"""
    An interface to a field of rational functions and a main package structure

    A convenient way to construct a field is to provide a set of generators
    
    TODO
"""
mutable struct RationalFunctionField
    generating_set       #
    groebner_set         # lazy field, not to be addressed directly
end


function RationalFunctionField(genset)
    RationalFunctionField(genset, [])
end

"""
    Returns generators of the given rational function field
    
    If the relative groebner ideal was already computed, 
    groebner coefficients are returned
"""
function AbstractAlgebra.gens(FF::RationalFunctionField)
    if isempty(FF.groebner_set)
        return FF.generating_set
    else
        return groebner_structure(FF.groebner_set)
    end
end

"""
    Assesses the membership of the given `elem` in the provided field `FF` 
    with the given probability of a correct answer `p` 

    Correctness of this algorithm relies on *Theorem 3.3* from
        *Structural identifiability via input-output projections, Pogudin et alia*
"""
function contains_randomized(
            FF::RationalFunctionField, elem;
            p=0.99)
    
    # Theorem 3.3 from
    # Structural identifiability via input-output projections, Pogudin et alia

    # choose appropriate to the given 'p' random upper bound 
    n = length(gens(parent(numerator(elem))))
    d = maximum([
            maximum([degrees(numerator(f))..., degrees(denominator(f))...])
            for f in FF.generating_set
    ])
    M = round(Int, 6d^(n+3) / (1 - p))
    
    @info "Random values bound M = $M"
    
    # idealize the generators and the elem simultaneosly
    elements_all = push!(deepcopy(FF.generating_set), elem)
    I_all = idealize(elements_all)
    ground = I_all.ground    

    @info "" typeof(I_all.I[1])

    singular_ground = tosingular(ground)
    eval_ring, evalvars = Singular.PolynomialRing(
                              singular_ground,
                              I_all.ystrings,
                              # Gleb: why and what is this? To discuss
                              ordering=ordering_lp(I_all.nvariables)*ordering_c())
    
    I = I_all
    i = deepcopy(I)
    i.I = [i.I[end]]
    I.I = I.I[1:end-1]
    
    # evaluate at a random point
    G = GroebnerEvaluator(I.I, eval_ring, I.basepolyring, ground, saturated=false)
    g = GroebnerEvaluator(i.I, eval_ring, I.basepolyring, ground, saturated=false)

    p = generate_point(G, M=M)

    gb = evaluate(G, p)
    elem = evaluate(g, p)    

    @debug "Evaluated eLement is $elem"
    @debug "Evaluated groebner basis is $gb"

    Is = Singular.Ideal(eval_ring, gb)
    
    # check ideal membership
    return iszero(Singular.reduce(elem..., GroebnerBasis.f4(Is)))
end

"""
    Assesses the membership of the given `elem` in the provided field `FF` 
    
    If the groebner ideal corresponding to FF generators is not computed yet,
    this might take some time
"""
function contains_using_groebner(FF::RationalFunctionField, elem)
    
    if isempty(FF.groebner_set)
        compute_groebner!(FF)
    end

    Is, yoverx, basepolyring, yoverxs, basepolyrings = groebner_ideal_to_singular(FF.groebner_set)

    f = idealize_element(elem, basepolyring, basepolyrings, yoverx, yoverxs)

    fs = Ideal(yoverxs, f)
    Is = Ideal(yoverxs, Is)
    Singular.contains(Is, fs)
end


function compute_groebner!(FF::RationalFunctionField)
    FF.groebner_set = groebner_ideal(gens(FF))
end


function simple_preprocess(generators)
    tmp = filter((c) -> !isconstant(c), generators)
    sort!(tmp, by=(c) -> sum(degrees(c)), rev=true)
    ans = [ first(tmp) ]
    for elem in tmp
        field = RationalFunctionField(ans)
        compute_groebner!(field)
        if !contains(field, elem, p=1)
            push!(ans, elem)
        end
    end
    ans = [ x * inv(Nemo.lc(numerator(x))) for x in ans ]
    ans
end

"""
    Simplifies generators of the given RationalFunctionField
    by computing the Groebner Basis of the corresponding good ideal
    and applying some heuristics to its coefficients after
"""
function simplify!(
            FF::RationalFunctionField;
            backend_algorithm=simple_preprocess)
    FF.generating_set = backend_algorithm(copy(gens(FF)))
end

"""
    Assesses the field membership of `elem` in `FF` by checking
    if `elem` lies in the "good" ideal generated by the given field generators

    `p` - probability of a correct answer (both positive and negative)

    If p is set to 1, deterministic algorithm is used

"""
function Base.contains(FF::RationalFunctionField, elem; p=0.99)
    if isone(p)
        contains_using_groebner(FF, elem)
    else
        contains_randomized(FF, elem, p=p)
    end
end























